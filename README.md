# Computer Architecture: 구현 과제

이 과제는 32비트 RISC-V 기본 명령어를 기계어로 변환하고, 실행 중 프로그램 카운터(PC) 값을 기록하는 시뮬레이터를 구현하는 것입니다.

## 구현 조건

- 언어: C (Linux 환경, GCC 사용)
- 명령어: 총 24개  
  - 23개 RISC-V 기본 명령어: `ADD`, `SUB`, `ADDI`, `AND`, `OR`, `XOR`, `ANDI`, `ORI`, `XORI`, `SLL`, `SRL`, `SRA`, `SLLI`, `SRLI`, `SRAI`, `LW`, `SW`, `BEQ`, `BNE`, `BGE`, `BLT`, `JAL`, `JALR`
  - 1개 추가 명령어: `EXIT` (기계어 코드 0xFFFFFFFF)
- 레지스터: `x0`~`x31` 사용 (이름 사용 불가)
  - 레지스터 초기값: `x1 = 1`, `x2 = 2`, `x3 = 3`, `x4 = 4`, `x5 = 5`, `x6 = 6` 
  - 나머지 초기값: `0`
- 명령어 대소문자 구분 없음

##  입력

- 실행 시 사용자로부터 입력 파일명을 받음
- 파일이 없으면 오류 메시지: `Input file does not exist!!`
- 입력은 `.s` 파일 (한 줄에 하나의 명령어, 공백 줄 무시)
- `terminate`를 입력하면 프로그램 종료

##  출력

- 문법이 맞으면:
  - `.o` (기계어 파일)
  - `.trace` (PC 값 기록 파일)
- 문법 오류가 하나라도 있으면:
  - 메시지 출력: `Syntax Error!!`
  - `.o`, `.trace` 파일 생성하지 않음

##  제출 사항

- 구현 코드: `.c` 파일 1개 (압축 금지)
- 보고서: `.pdf`로 제출
  - 첫 줄: 컴파일 옵션
  - 주요 구현 설명 및 실행 스냅샷 포함
  - 전체 소스 포함할 필요 없음
- 제출 요건 미충족 시 -10% 감점

---

##  실행 예

### test1.s

```s
ADD x7, x1, x2
SUB x8, x3, x4
AND x9, x5, x6
OR x10, x7, x8
XOR x11, x9, x10
ANDI x12, x11, 11
ORI x13, x12, 15
XORI x14, x13, 12
SLL x15, x14, x2
SRL x16, x15, x3
SRA x17, x16, x4
SLLI x18, x17, 2
SRLI x19, x18, 1
SRAI x20, x19, 1
LW x21, 0(x1)
ADD x22, x1, x2
SUB x23, x2, x1
AND x24, x22, x23
OR x25, x22, x23
SW x21, 8(x2)
```

### test1.o

```
0000000000100000100000111011001101000000010000011000010000110011000000000110001011110100101100110000000010000011111001010011001100000000101001001100010110110011000000001011010111110110000100110000000011110110011001101001001100000000110001101100011100010011000000000010011100010111101100110000000000110111110110000011001101000000010010000101100010110011000000000010100010011001000100110000000000011001010110011001001101000000000110011101101000010011000000000000000010101010100000110000000000100000100010110011001101000000000100010000101110110011000000010111101101111100001100110000000101111011011011001011001100000001010100010010010000100011
```

### test1.trace

```
1000
1004
1008
1012
1016
1020
1024
1028
1032
1036
1040
1044
1048
1052
1056
1060
1064
1068
1072
1076
```

---

### test2.s

```s
ADD x7, x1, x0
SUB x8, x7, x1
ADDI x8, x0, 9
ORI x9, x8, 45
LOOP:
ADD x7, x7, x8
SUB x9, x9, x8
BGE x9, x8, loop
ADDI x9, x0, 5
ADDI x7, x0, 7
BGE x7, x9, LAB 
ADD x10, x1, x2
LAB:
SUB x11, x3, x4
```

### test2.o

```
000000000000000010000011101100110100000000010011100001000011001100000000100100000000010000010011000000101101010001100100100100110000000010000011100000111011001101000000100001001000010010110011111111101000010011011100111000110000000001010000000001001001001100000000011100000000001110010011000000001001001111010100011000110000000000100000100001010011001101000000010000011000010110110011
```

### test2.trace

```
1000
1004
1008
1012
1016
1020
1024
1016
1020
1024
1016
1020
1024
1016
1020
1024
1016
1020
1024
1028
1032
1036
```

---

### test3.s

```s
ADD x7, x1, x2
SLLI x8, x7, 2
SRLI x9, x8, 1
JAL x1, func1
ADD x12, x1, x3
SUB x13, x4, x2
AND x14, x5, x6
LW x19, 4(x1)
ADD x20, x19, x2
SLLI x21, x20, 1
SRLI x22, x21, 2
SW x22, 4(x2)
EXIT
func1:
ADD x15, x1, x2
SUB x16, x3, x4
ADD x17, x5, x6
OR x18, x1, x2
JALR x0, 0(x1)
```

### test3.o

```
000000000010000010000011101100110000000000100011100101000001001100000000000101000101010010010011000000101000000000000000111011110000000000110000100001100011001101000000001000100000011010110011000000000110001011110111001100110000000001000000101010011000001100000000001010011000101000110011000000000001101000011010100100110000000000101010110110110001001100000001011000010010001000100011111111111111111111111111111111110000000000100000100001111011001101000000010000011000100000110011000000000110001010001000101100110000000000100000111010010011001100000000000000001000000001100111
```

### test3.trace

```
1000
1004
1008
1012
1052
1056
1060
1064
1068
1016
1020
1024
1028
1032
1036
1040
1044
1048
```
